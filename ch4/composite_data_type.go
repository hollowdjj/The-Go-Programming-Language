/*
第四章：复合数据类型
1. 数组
var a [3]int   					//定义一个含有三个int类型元素的数组a，数组元素执行的默认初始化，即0
var a [3]int = [3]int{0,1,2} 	//使用字面值初始化数组
var a [3]int = [3]int{1,2}      //a[2]为0
a := [...]int{1,2,3}            //省略号数组的长度由字面值决定

上面的形式是直接提供顺序初始化值序列，在go中还可以通过指定特定索引的方式进行数组初始化
type Currency int
const (
	USD Currency = iota  // 0
	EUR					 // 1
	GBP					 // 2
	RMB					 // 3
)
symbol := [...]string(USD: "$",EUR: "€",GBP: "£",RMB: "￥")
这种情况下初始化顺序无关紧要，并且可以只初始化部分索引，其余索引将执行默认零值初始化，如
r := [...]int{99:-1}   //定义了一个含有100个元素(99 + 1)的数组，其中第99个元素被初始化为-1，其余元素均为0

2. Slice切片
slice是一个轻量数据结构，提供了访问数组子序列或全部元素的功能，是对数组中子序列或全部元素的引用。这个数组可以是一
个已存在的非匿名数组，也可以是一个底层的匿名数组，从而slice的创建主要有三种形式：
1) var vec []int{1，2，3}  		//看起来和数组的声明很像，然而数组必须在[]里写长度或者省略号
2) 内置make函数  make([]T,len)  make([]T,len,cap) 前者没有指定容量则len == cap
3）对一个已存在的非匿名数组进行切片操作

slice可使用append函数来追加元素。然而，需要注意的是，我们通常清除append函数的内存扩展策略，从而也就不能确认返回的
新slice是否还和原来的slice引用的是同一个底层数组，进而无法确定对原slice的操作是否会影响到新的slice。所以，append
函数的一般使用方法是将其返回的slice直接赋值给输入的那个slice变量

arr[i:j]  //从数组arr中引用第i个元素到第j-1个元素(左闭右开)，其中i和j都是可以省略的，如：
arr[:j]   //省略i则默认是0
arr[i:]   //省略j则默认是len(arr)
arr[:]    //相当于arr[0:len(arr)]

slice的值包含指向第一个slice元素的指针，因此当slice作为函数的参数传递时，传递的是指针，从而可在函数内部对slice
进行的任何操作都会影响到外面的slice。

3. Map
map的创建有三种方式：
1) m := make(map[string]int)  						//使用make函数创建一个空的map
2) m := map[string]int{"alice": 31,"charlie: 34",}  //使用字面值创建一个带初始值的map
3) m :+ map[string]int{}                            //创建一个空的map
map是复合类型，这意味这在声明一个map却没有指定初始值时，默认执行的是零值初始化，而map的零值为nil，如
var m map[string]int    //此时m是一个nil值的map
map的查找、删除、len和range循环都可以很安全的工作在一个nil值map上，但是向一个nil值的map存于元素将到值panic异常

在map中查找一个不存在的元素时，会返回对应的value的零值。然而，当value为int类型时，我们又想分辨返回的这个0是代表
元素不存在，还是元素存在但其value刚好为0的情况，此时可以这样操作：
if age,ok := ages["bob"]; !ok {...}   //第二个值是一个bool类型的变量，true表示元素在map中，false表示元素不在map中

4. 结构体
和C++基本一致，但有几点需要注意：
1) 结构体中成员出现的顺序有重要意义。交换成员出现的先后顺序会导致不同的两个结构体，将相邻两同类型的成员写在同一行或分行写例外。
2) 结构体成员首字母大写是导出的，小写则是非导出的。
3) 结构体中所有成员都是可比较时，结构体也是可比较的。
*/

package ch4

func test() {
}
